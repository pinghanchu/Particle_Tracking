Calibration is the process that provides us with the orientations of the cameras. It's used all the time, including correspondences. Since it works, I believe that it's all fine. C reads ori files (according to the names given in parameters files) and assigns a matrices for each camera. The calibration process is therefore absolutely external to the main workflow. The user can run it separately and create the *.ori (and also *.addpar) files as many as he wants before he starts tracking. Then the only thing is to provide the list of the names into parameters. In calibration parameters, user give names of the files to be created and in the main parameters user gives names to be used. So the only thing calibration does is to create these files. Therefore I believe it can be in a separate window, but it's not necessary, we can keep the same one as well. 

The structure of the GUI is similar: image window per camera, some way to fire different sub-processes (Load images, Detect points, Mark points, Use previously marked points, ....) and change calibration parameters that are used by the C code. so also here we need to write parameters and read parameters all the time. Here, however, I believe C code reads it all the time, so no need to "refresh" - it's very interactive process. In short the process is as follows:

user loads calibration images - images of the known target, e.g. some dots on the plane. Each dot has a number and a position in space. Every camera sees these dots from different perspective. User provides a file with the list of the dots and their position in space. the software needs to find a position of the cameras that will provide closest solution - every dot will be found and numbered according to the list provided. Then, if all goes well, the camera knows where it's located such that the dots are all fit. So, load images, detect their centers (using very similar to the preprocessing way, up to detection). Then user is asked to click 4 points on each image and we need to provide this functionality. there's no check on it, The marked points are numbered and their x,y locations are saved in some file (man_ori.dat i believe). This is usually done only once and every next time (iteration) user can simply load this file and replot the marks given last time. So there is something to add to drawcross - also write a number of the dot next to it. 
After this interactive clicking and showing the dots, user goes to the projection of the known list of points (from the ASCII file) onto the image, it is called "initial guess'". the software reads manually created *.ori files and projects them on the calibration image (yellow color crosses, no numbers). If the fit is okay, one can use this guess or let software to find some other solution, going to sortgrid function. Sortgrid uses the 4 clicks and the manually created *.ori files and builds the new fit, showing it in cyan color and numbers. If all is well and it's user's responsibility to check it, then the user can press Orient and solve the orientation matrices of each camera. This is usually repeated many times by the following workflow. Initially, no additional parameters are allowed to change and user find the orientation by Orient, then checking in some options in the change calibration parameters window and Orientation again, and so on, until most of the possibilities are checked in and checked out in some fashion. There's no strict rules. So, definitely, C code reads the parameter file each time it runs and also every time we change something in parameters has to be written and saved. 
After all these games, there are new (rewritten) *.ori files that are in the /cal folder usually. if user wishes, he can create new set of /cal1/ files and so on. Then in main parameters he only choses which set to use by typing in the names. 
Additional, pretty new calibration options are Shaking, Dumbbells are different and we shall get to them later. I think once we implement the "simple" one, it will automatically work as well. 

There are also some code that allows us to use multiple plane calibration images, if you run into it and it's cumbersome, leave it for the moment, we get to it later. I think there's some strange way of dealing with it by running the same thing many times and saving some temporary files and then combining them somehow. I'm not even sure I remember how it works as we used it long time ago. So if it stops the progress, leave it. 

.mbar.track.menu add command -label "Detected Particles" -command "marktrack_cmd"
.mbar.track.menu add command -label "Tracking with display" -command "trackcorr_cmd 1"
.mbar.track.menu add command -label "Tracking without display" -command "trackcorr_cmd 0"
.mbar.track.menu add command -label "Tracking backwards" -command "trackback_cmd 0"
.mbar.track.menu add command -label "Sequence/Tracking" -command "sequence_cmd 0;trackcorr_cmd 0"
.mbar.track.menu add command -label "Show Trajectories" -command "trajectories_cmd"
.mbar.track.menu add command -label "VRML Tracks" -command "VRMLtracks"
.mbar.track.menu add command -label "VRML Detection" -command "VRMLdetections"
.mbar.track.menu add command -label "VRML Detection + Tracks" -command "VRMLdettracks"
#.mbar.track.menu add command -label "PTV" -command "ptv_cmd"

